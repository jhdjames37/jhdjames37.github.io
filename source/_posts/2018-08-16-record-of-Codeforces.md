---
title: Codeforces FST 记录
date: 2018-08-16 10:09:19
categories:
- oi
- reviews & plans
tags:
- Codeforces
- review
---

暑假里 VP 了 $O(1)$ 场 CF。现记录如下（大致就是 2014 年底到 2015 年初的）

<!--- 目前只是 Overview，应该要加上一些细节和经验。--->

<!--- more --->

## Codeforces Round #282

A, B 略

C 首先将区间转树，然后 DP。
第二维状态应该是 (现在的最大值 - 初始的最大值)

D 直接从下到上，从上到下分别 DP 出二次和，然后将链和子树合并。（细节咕咕咕）

E 根据题解上的证明（比较复杂，先咕着**TODO**），每个格子 $(i, j)$ 的 SG 值为 $\min(\text{lowbit}(i), \text{lowbit}(j), \text{highbit}(k))$ （$\text{highbit}$ 的定义类似 $\text{lowbit}$）。所以总的 SG 值为所有 1 的格子的 SG 值的异或。

考虑有几个格子的 SG 值 $\geq x$ （显然$x \le \text{highbit}(k)$）最后差分一下。

那么可以转化成二维区间覆盖 + 数点，用扫描线 + 线段树。

在线段树实现上，用类似标记持久化的思想，不下传标记，根据是否有标记决定是否 `update`。

另外，因为只需要知道数量的奇偶性，所以可以压位放在一个线段树上搞。

## Codeforces Round #283

VP 的时候没什么差错，只是计算几何写翔了。

A 略

B 复杂度分析（O(调和级数)）

C 将区间包含转为二维数点之后贪心。

D 计算几何。利用相对运动来简化判定的形式（不仅要固定一个点，而且要让其中一条边不转）。考虑边界情况，旋转的线段相交可以变成旋转的点（圆）和线段相交。

E 用数位 DP 的思想，逐位递推。矩阵快速幂优化。

## Codeforces Round #284

(著名的 dreamoon & sorry_dreamoon 场)

这一场 VP 的时候被榜带错了，直接开 C，结果因为没拆点，直接跑（魔改）匈牙利，WA 了无数发（这样写细节会出事），然后赛后 1 分钟过 B。（其实 D，E 也不难，就是两小时可能写不出来）

A 略

B 概率 DP 卡常题

C 按质因数拆点跑二分图匹配。

D 暴力建线段树，维护 $T \bmod 60$ 下的 DP 值

E 矩阵优化状压 DP。

## Goodbye 2014

这场 FST 了一题。因为边界判错了。

A, B, C, D略 （居然 A FST 了一发）

E 数据结构优化模拟。（细节 WA 了很多，最后写了 2 个 $\log$ 的）

最后我写的是 `range_tree`，每次合并的时候要二分出第一个不被撞到的点。

F O(调和级数) + 关键点 / 扫描线 + 双栈队列

前一种很常见，后一种的意思是用两个栈来模拟队列，同时维护 DP 值，这样插入删除都是在可接受范围内的。

G 数论 + 树论神题（详细讲一下最后几步细节的推导, TODO）

## Codeforces Round #285

这一场手速不够，而且 C 题因为一个式子打错 FST 了（居然过了 39 个点），D 题算错转二进制的复杂度然后在死命卡 bitset。。。

A, B略

C 大分讨

题解上好像没有分讨，我大致分成了端点跨过中线，端点都在一侧，另外为了防止算重加上了端点在中线上和端点关于中线对称的情况。好像也可以直接 two pointer

D 线性基裸题，高精度转二进制（实际是 $O(\frac{n^2}{w}) 的$，必须压位才能过）

E 轻重链剖分 + SA + 在 $\log$ 条链上扫 / 整体二分（主要是为了 $O(n)$ 求出长度为 $\text{mid}$ 的位置）+ hash + 卡常

## Codeforces Round #286

这场没有 VP 记录，因为爆零了（A题多了个 $\log$ 然后就死活过不去。。。）

A 缩减状态数（$n\sqrt{2n}$个状态）

B 缩点 + 分析（挺好的题目）

对于一个弱连通分量：

+ 存在SCC：建成环（一开始以为是每个SCC建一个环，实际不需要）
+ 不存在SCC：建成链

只要并查集 + tarjan 判一下。

C 贪心 + 推式子 / 逆向思维（也是挺好的题目）

假设二分答案 $x$

1. 反向推（从高度为 $x$ 出发，每次贪心选择最早会爆负的 $k$ 个加上去，最后的高度要高于初始高度），容易证明正确性。

2. 而如果直接计算出第 $i$ 个操作的最早发生时间 $t_i$ 的时候（即求最小的 $t$ 满足 $\max(0, at - ip) + a(m - t) - (n - i)p \le x$），就需要稍微推一下，如果将某些操作提前（但不小于 $t_j$）不会影响正确性（因为计算时假设前 $i$ 次操作都在 $t$ 进行，后 $n - i$ 次操作都在最后进行），也就是证明只要在合法时间段内操作，所有操作独立。

D 复杂度分析（按照$\sqrt{n}$分类） + 减少不必要枚举（枚举较少的出边）

E 自动机 DP 上套矩阵（好像可以推式子）

听完毕姥爷讲课，发现可以直接线性递推用 BM(Berlekamp Massey Algorithm) （或者高消）来做。。。

---

再来看最近的一场

## Codeforces Round #503

两（3？）题手速场（话说 C 题 pp 比 D 多，把我带去做 C 了。。。最后只剩 7 个没 FST，中间好像还有乱搞）

A，B 略（话说前两天我还看到了 B 的连续版本）

C 递归构造，每次考虑删除一个点和它的出边所到达的点，求出子问题答案后分这个点是否一步可达讨论。（似乎大家都在缩点后乱搞）

D 将 $O(n^2)$ 条线段极角排序，扫描时维护每个点到扫描线的距离关系（带符号），利用两个点的距离大小关系只在扫描线角度和两点连线极角相同是改变维护。~~$O(n^3)$卡常：CF 机子是 32 位机，所以先求模 $2^{32}$ 意义的值。或者预处理叉积~~

E 边分 + 凸包合并 （写点分容易变成 3 个 $\log$ 或者在 $m$ 上多一个 $\log$）标算$O(n \log^2 n + m)$
