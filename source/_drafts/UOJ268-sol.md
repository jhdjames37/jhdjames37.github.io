---
title: UOJ268 - 【清华集训2016】数据交互
date: 2018-04-03
categories:
- oi
- solutions
tags:
- trees
- UOJ
- segment tree
---

UOJ268 - 【清华集训2016】数据交互

<!--- more --->

## 题意：
给出一棵树，有$m$次操作，每次操作为标记一条路径并给它一个权值，或删除一个标记。每次操作后找出一条路径，使得其经过的标记过的路径的权值和最大(一条路径经过另一条路径当且仅当这两条路径有公共点)， 输出最大的权值和。 $n, m \le 10 ^ 5$.

## 题解：

首先考虑如何计算一条路径的答案（权值和）：

考虑这条路径的LCA L点（即端点的LCA）， 则一条标记过的路径对这条路径有贡献有两种情况：
1. 标记过的路径经过L点
2. 标记过的路径的LCA在这条路径上。

那么我们设$cov_i$为经过i点且LCA不为i点的标记路径权值和，$cnt_i$为LCA为i点的标记路径权值和。那么我们可以发现这个问题和树的直径有些类似： 设$f_i = \max_{v \in son_i} f_v + cnt_i$, 则LCA为i点的路径的权值和的最大值为$val_i = cov_i + cnt_i + \max_{j, k \in son_i j \neq k} f_j + f_k$ 则我们只需要维护$\max val_i$即可。

考虑树链剖分：发现$val_i$本质上就是一条LCA为i的路径上点的$cnt_i$之和$+cov_i$。考虑LCA所在的重链，则容易发现每一条路径都可以被拆分成3段：由轻边引出的一段 + 重链的一部分$u, v$ + 由轻边引出的一段。分别设这三段$cnt$之和为$g_u$, $w_{u, v}$, $g_v$, 其中$dfn_u \le dfn_v$, 即u为LCA。则答案为$\max g_u + cov_u + w_{u, v} + \max g_v$。但是当$u = v$时， $g_v$ 要取第二大的。

最后考虑如何维护： 对于每一条重链分别建立线段树，用类似最大子段和的方式维护答案。同时对每一个结点维护一个堆（因为要支持删除，所以需要两个`std::priority_queue`， 其中一个存放删除的内容。取最大值的时候如果两个堆顶元素相同，就同时$pop$(也许可以使用`std::multiset`?)）， 维护轻边上的$g—_i$的最大值。每次修改的时候，先修改路径上的cov以及LCA上的cnt值。同时将路径上的以及LCA到根节点的g值更新。


